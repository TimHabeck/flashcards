DATA MINING

Kapitel 10: Streams
Dr. Christian Martin
Wintersemester 2025/26

Abteilung Datenbanken / ScaDS.AI
UniversitÃ¤t Leipzig

THEMENÃœBERSICHT

Hochdimensionale Daten

Graphdaten

Streams

Clustering

Dimensionsreduktion

Community
Detection

Windowing

Empfehlungssysteme

Assoziationsregeln

Centrality

Filtern

Locality Sensitive
Hashing

Supervised
Learning

Momente

10-2

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl eindeutiger Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-3

DATA STREAMS
âˆ’ In vielen Situationen liegt der Datensatz zum Zeitpunkt
der Analyse nicht vollstÃ¤ndig vor
âˆ’ Data Stream (Datenstrom) = Daten sind unbegrenzt und
die Rate der Eingabe ist nicht kontrollierbar
âˆ’ Annahmen
âˆ’ Daten treten als â€unbegrenzter Streamâ€œ mit einer sehr hohen
Frequenz Ã¼ber einen oder mehrere EingÃ¤nge auf
âˆ’ ZugÃ¤ngliche Speicherung der Daten (auf Festplatte) unmÃ¶glich
âˆ’ Daten werden sofort verarbeitet und danach verworfen
Wie sind kritische Berechnungen Ã¼ber den Data Stream mit einer
begrenzten Menge an Speicher mÃ¶glich?

10-4

DATA STREAM MODEL
Ad-Hoc
Anfragen

. . . 1, 5, 2, 7, 0, 9, 3

Stream
Prozessor

. . . a, r, v, t, y, h, b
. . . 0, 0, 1, 0, 1, 1, 0
Eingabe Data Streams
â€¢ Bestehend aus Elementen
verschiedenen Typs
â€¢ Unterschiedliche Frequenz

StÃ¤ndige
Anfragen

Speicher fÃ¼r
Zwischenergebnisse
(RAM/Festplatte)

AusgabeStreams

Archive

(schwer zugÃ¤nglich)
10-5

BEISPIELE FÃœR DATA STREAMS
âˆ’ Sensordaten
âˆ’ Millionen Sensoren senden Daten an zentrale Einheit
âˆ’ z.B. Wasserstand/Temperatur in FlÃ¼ssen/Seen/Meeren
âˆ’ 10 Werte pro Sek. mit 4 Byte: 3.4 Mbyte pro Tag pro Sensor

âˆ’ Query Beispiele
âˆ’ Durchschnittlicher Wert pro Stunde
âˆ’ Min, Max und Durchschnittlicher Wert pro Minute Ã¼bersteigt Threshold
âˆ’ HÃ¶chster je gemessener Wert eines Sensors

Quelle: https://www.newscientist.com/article/2303899-outsider-wins-darpa-challenge-to-predict-where-floats-drift-at-sea/

10-6

BEISPIELE FÃœR DATA STREAMS (2)
âˆ’ Anfragen an Suchmaschine
âˆ’ Welche Anfragen werden heute hÃ¤ufiger gestellt, als gestern?
âˆ’ z.B. Anfragen wie â€Symptome Grippeâ€œ kÃ¶nnen auf Grippewelle
hinweisen

âˆ’ Click-Streams
âˆ’ Nutzerverhalten (Navigation) auf Webseite
âˆ’ Query: Top 10 der meist geklickten Artikel pro Tag, Woche und Monat

âˆ’ News-Feed auf Sozialen Medien
âˆ’ IP/Telefon-Daten
âˆ’ Informationen fÃ¼r optimales Routing der Pakete
âˆ’ Erkennung von Denial-of-Service-Attacken (DoS)

âˆ’ Online Machine Learning (z.B., Stochastic Gradient Descent)

10-7

STREAM PROCESSING HERAUSFORDERUNGEN
âˆ’ Hohe Frequenz
âˆ’ Verarbeitung in Echtzeit
âˆ’ Berechnungen im RAM anstatt Disk

âˆ’ Hohe Anzahl der zu verarbeitenden Streams
âˆ’ RAM reicht oft nicht aus, um alle Streams zu verarbeiten

âˆ’ AnsÃ¤tze
âˆ’ Approximative anstatt exakte Antwort
âˆ’ Stichprobe anstatt gesamte Daten
âˆ’ Neuste anstatt gesamte Daten
âˆ’ Window Processing fÃ¼r aktuellste Ergebnisse

10-8

BEISPIEL: APACHE KAFKA
âˆ’ Verteilte Streaming-Plattform
âˆ’ Verarbeitung groÃŸer Mengen an DatenstrÃ¶men in Echtzeit

âˆ’ Hohe Skalierbarkeit
âˆ’ Horizontales skalieren = leichtes Erweitern von Ressourcen um mit
wachsenden Datenmengen umzugehen

âˆ’ Echtzeit-Datenverarbeitung
âˆ’ Producer und Consumer
âˆ’ Publish-Subscribe-Modell: Producer senden Daten an Topics,
Consumer kÃ¶nnen diese Daten abonnieren und verarbeiten

âˆ’ Robuste Architektur
âˆ’ GewÃ¤hrleistet hohe VerfÃ¼gbarkeit und Fehlertoleranz

âˆ’ Wurde ursprÃ¼nglich von LinkedIn entwickelt
âˆ’ 2011 als Open-Source-Projekt der Apache Software Foundation
verÃ¶ffentlicht
10-9

BEISPIEL: APACHE FLINK
âˆ’ Verteiltes Stream- und Batch-Verarbeitungssystem
âˆ’ Batch wird als Sonderform von Streaming betrachtet

âˆ’ Echtzeit-Datenverarbeitung
âˆ’ Low-Latency-Analysen auf groÃŸen hochfrequenten Streams

âˆ’ Hohe Skalierbarkeit
âˆ’ Zustandsbehaftete Verarbeitung
âˆ’ UnterstÃ¼tzt komplexe Event-Verarbeitung mit zustandsbehafteten
Operationen

âˆ’ Integrierte Fehlertoleranz
âˆ’ Exactly-Once-Semantiken via Checkpointing
âˆ’ Entwickelt als Forschungsprojekt an der TU Berlin, 2014 als OpenSource-Projekt verÃ¶ffentlicht
âˆ’ 2024: Release von Version 2.0
10-10

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl eindeutiger Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-11

ZIEHEN EINER STICHPROBE
âˆ’ Auswahl und Speicherung einer reprÃ¤sentativen
Teilmenge der Daten
âˆ’ Anfragen auf Stichprobe anstatt gesamten Daten
âˆ’ Zwei Arten
âˆ’ Fester Anteil des Datenstroms: z.B. 1 von 10 Elementen, d.h.
die Stichprobe wÃ¤chst kontinuierlich mit der Zeit (mit dem
Datenstrom)
âˆ’ Feste Anzahl an Elemente: z.B. 10.000 Elemente, d.h. die
Stichprobe hat eine feste maximale GrÃ¶ÃŸe

10-12

STICHPROBE MIT FESTEN ANTEIL
âˆ’ Elemente: (ID, Zeitpunkt, Attribut 1, Attribut 2, â€¦)
âˆ’ Implementierung Ã¼ber Hashfunktion:
âˆ’ WÃ¤hle eine/mehrere Komponenten der Elemente als SchlÃ¼ssel, z.B. ID,
Zeitpunkt oder ein Attribut
ğ‘

âˆ’ FÃ¼r einen Anteil von ğ‘, verwende ğ‘ Buckets und speichere ein Element,
falls der Hash-Wert des SchlÃ¼ssels in einen der ersten ğ‘ Buckets fÃ¤llt
âˆ’ z.B. fÃ¼r eine 30%-Stichprobe:

âˆ’ Wahl des SchlÃ¼ssels hÃ¤ngt von Anwendung/Frage ab
âˆ’ Beispiel: Anfragen an Suchmaschine
âˆ’ Elemente: (ID, Zeitpunkt, Nutzer, Anfrage)
âˆ’ Frage: Wie oft stellen die Nutzer die gleiche Anfrage (im Durchschnitt)?
âˆ’ Anteil: 10%
10-13

STICHPROBE MIT FESTEN ANTEIL
âˆ’ Naive LÃ¶sung: Hash-Funktion auf ID der Elemente
âˆ’ Auswahl von 10% der Elemente
âˆ’ Problem: Abweichung Erwartungswert der Stichprobe von tatsÃ¤chlichem Wert
âˆ’ Beispiel:
âˆ’ Ein Nutzer stellt x einzigartige Anfragen und d Duplikate
âˆ’ Exakte Antwort:

ğ‘‘
ğ‘‘+ğ‘¥

der Anfragen sind Duplikate

âˆ’ ABER: Erwartungswert der naiven SchÃ¤tzung:

ğ‘‘
19ğ‘‘+10ğ‘¥

(Herleitung siehe [1])

âˆ’ Bessere LÃ¶sung: Hash-Funktion auf Nutzer
âˆ’ Auswahl von 10% der Nutzer
âˆ’ Speichere alle Anfragen der ausgewÃ¤hlten Nutzer

[1] Mining of Massive Datasets â€“ Chapter 4, Leskovec et al.

10-14

STICHPROBE FESTER GRÃ–SSE
âˆ’ Stichprobe darf eine GrÃ¶ÃŸe ğ‘  nicht Ã¼berschreiten, z.B. aufgrund von
SpeicherbeschrÃ¤nkungen
âˆ’ ErwÃ¼nschte Eigenschaft: Nachdem ğ‘› Elemente eintrafen, ist jedes
ğ‘ 
dieser Elemente mit Wahrscheinlichkeit Teil der Stichprobe
ğ‘›

âˆ’ Beispiel mit ğ‘  = 2: a b c d e f g h g iâ€¦
2
7

âˆ’ Nach n = 7: alle 7 Elemente sind mit Wahrscheinlichkeit Teil der Stichprobe
âˆ’ Nach n = 10: alle 10 Elemente sind mit Wahrscheinlichkeit
(bzw.

4
fÃ¼r â€œgâ€).
10

2
Teil der Stichprobe,
10

Algorithmus (a.k.a. Reservoir Sampling)
â€“ Speichere die ersten ğ‘  Elemente des Datenstroms
â€“ Ein neues Element (ğ’-te Element) trifft ein (ğ’ > ğ’”):
Mit Wahrscheinlichkeit p = s/n,
â€¢ Ersetze eins der vorhandenen ğ’” Elemente (zufÃ¤llig ausgewÃ¤hlt
nach Gleichverteilung) durch das ğ’-te Element.
10-15

BEWEIS DER ERWÃœNSCHTEN EIGENSCHAFT
ğ‘ 

âˆ’ "Nachdem ğ‘› Elemente eintrafen, ist jedes dieser Elemente mit Wahrscheinlichkeit
ğ‘›
Teil der Stichprobe."
âˆ’ Beweis durch vollstÃ¤ndige Induktion
âˆ’ Induktions-Anfang: Nachdem ğ‘› = ğ‘  Elemente eintrafen, sind alle Elemente mit
ğ‘ 
Wahrscheinlichkeit = 1 in der Stichprobe
ğ‘›

âˆ’ Induktions-Schritt: Angenommen die erwÃ¼nschte Eigenschaft (s.o.) gilt fÃ¼r ğ‘›
Elemente. FÃ¼r das Eintreffen des (ğ‘› + 1)ten Elements gilt:
âˆ’ Das (ğ‘› + 1)te Element wird mit Wahrscheinlichkeit

ğ‘ 
ğ‘›+1

in die Stichprobe aufgenommen.

âˆ’ Jedes der ğ‘› Elemente aus vorherigen Stichprobe bleibt darin, d.h., (n+1)te Element wird nicht
gewÃ¤hlt oder wird gewÃ¤hlt aber ersetzt nicht ğ‘›, mit Wahrscheinlichkeit
ğ‘ 
ğ‘ 
ğ‘ âˆ’1
ğ‘›
1âˆ’
+
âˆ™
=
ğ‘›+1
ğ‘›+1
ğ‘ 
ğ‘›+1
ğ‘ 
âˆ’ Also: zum Zeitpunkt ğ‘›, sind alle Elemente in s mit einer Wahrscheinlichkeit
âˆ’ Nachdem ğ‘› âŸ¶ ğ‘› + 1, bleiben Elemente in s mit einer Wahrscheinlichkeit

ğ‘›
ğ‘›

ğ‘›+1

âˆ’ Jedes der vorherigen ğ‘› Elemente ist in Stichprobe mit Wahrscheinlichkeit
ğ‘ 
ğ‘›
ğ‘ 
âˆ™
=
ğ‘› ğ‘›+1 ğ‘›+1

10-16

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl eindeutiger Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-17

ANFRAGEN MIT SLIDING WINDOW
âˆ’ Anfragen sind auf ein Sliding Window der LÃ¤nge N, d.h. auf die
neuesten N Elemente, beschrÃ¤nkt
âˆ’ Beispiel mit N = 6:

axcyzkcdegabfgd
âˆ’

Problem: unzureichender Speicherplatz fÃ¼r Sliding Windows, falls
âˆ’ N ist zu groÃŸ
âˆ’ zu viele DatenstrÃ¶me

âˆ’ Beispiel: Online HÃ¤ndler
âˆ’ Ein 0/1-Datenstrom pro Produkt
âˆ’ Information, ob das Produkt in der n-ten Transaktion verkauft wurde
âˆ’ Anfrage: Wie oft wurde ein Produkt in den letzten k Transaktionen
verkauft?
10-18

BITS ZÃ„HLEN
âˆ’ Gegeben ist ein 0/1-Strom, ein Sliding Window der LÃ¤nge N und
Anfragen der Form:
âˆ’ Wie viele Einsen sind unter den letzten k Bits (k â‰¤ N)?

N

010011100010100100010110110111001010110011â€¦
Vergangenheit

|

Zukunft

âˆ’ Exakte Antwort nur durch Speichern aller N Bits mÃ¶glich
âˆ’ Approximative Antwort durch Speichern aggregierter Daten: Anzahl
der Einsen in einem festen Bereich
âˆ’ z.B. nur 2 ZÃ¤hler und Annahme der Gleichverteilung (schlechte
LÃ¶sung)
âˆ’ S: Anzahl der Einsen seit Beginn
âˆ’ Z: Anzahl der Nullen seit Beginn
ğ‘º

âˆ’ Anzahl der Einsen unter den letzten ğ’Œ Bits: ğ’Œ âˆ™ ğ‘º+ğ’
10-19

EXPONENTIELL WACHSENDE BEREICHE
LÃ¤nge
der
Bereiche

16
8
4
2
1

Bereich aus 16 Bits mit 9 Einsen

9
6

4

3
N

2
2 1
10

11100010100100010110110111001010110011010

âˆ’ Idee: ZÃ¤hler fÃ¼r exponentiell wachsende Bereiche
âˆ’ Vorteil: Speicherbedarf
âˆ’ Anzahl der Bereiche: ğ‘¶(log 2 N)
âˆ’ Insgesamt: ğ‘¶(log 22 N) Bits (Speichern der Anzahl der Einsen pro Bereich
benÃ¶tigt maximal log 2 ğ‘ Bits)

âˆ’ Nachteil: groÃŸer Fehler mÃ¶glich, z.B. falls alle Einsen im Ã¤ltesten
Bereich

10-20

DGIM-METHODE
âˆ’ LÃ¶sung: Datar-Gionis-Indyk-Motwani-Methode
âˆ’ Anstatt von Bereichen mit bestimmter LÃ¤nge,
Zusammenfassen von Bereichen mit bestimmter Anzahl
an Einsen
2 Bereiche
der GrÃ¶ÃŸe 1
Mind. 1 Bereich
der GrÃ¶ÃŸe 16

2 Bereiche
der GrÃ¶ÃŸe 8

2 Bereiche 1 Bereich der
der GrÃ¶ÃŸe 4 GrÃ¶ÃŸe 2

â€¦.01010110001011010101010101011010101010101110101010111010100010110010

N

10-21

DGIM-BEREICHE
âˆ’ Jedes Element (Bit) des Datenstroms hat einen Zeitpunkt: 1, 2, â€¦
âˆ’ Ein DGIM-Bereich besteht aus
A: Dem Zeitpunkt des neuesten Eintrags
B: Anzahl der Einsen im Bereich als Zweierpotenz = die GrÃ¶ÃŸe des DGIM-Bereichs

âˆ’ Regeln:
âˆ’ Jedes 1-Bit fÃ¤llt in genau einen Bereich
âˆ’ Das rechte Ende eines Bereichs enthÃ¤lt eine Eins
âˆ’ Die GrÃ¶ÃŸe eines Bereichs (Anzahl der Einsen) muss eine Zweierpotenz sein
â†’ Speicherung der GrÃ¶ÃŸe benÃ¶tigt nur log 2 ( log 2 N) Bits
âˆ’ Von dem neuesten zu Ã¤lteren Bereichen ist dessen GrÃ¶ÃŸe monoton steigend
âˆ’ Bereiche verschwinden, wenn dessen Zeitpunkt auÃŸerhalb des Sliding Windows
liegt
âˆ’ Es gibt entweder einen oder zwei Bereiche einer GrÃ¶ÃŸe â†’ ğ‘¶ log 2 N Bereiche

â€¦.01010110001011010101010101011010101010101110101010111010100010110010
A:34, B:100 A:49, B:011 A:63, B:011 A:71, B:010 A:77, B:010 A:83, B:001 A:84, B:000 A:87, B:000
10-22

AKTUALISIERUNG DER DGIM-BEREICHE
âˆ’ Ankommen eines neuen Bit
âˆ’ Evtl. verschwindet Ã¤ltester Bereich (falls sein Zeitpunkt
auÃŸerhalb des Sliding Window liegt)
âˆ’ Falls neues Bit eine 0: keine weiteren Ã„nderungen
notwendig
âˆ’ Falls neues Bit eine 1:
1. Erstelle neuen Bereich der GrÃ¶ÃŸe 1 und aktuellem Zeitpunkt
2. Falls nun 3 Bereiche der GrÃ¶ÃŸe 1: Kombiniere die Ã¤lteren
beiden Bereiche zu einem Bereich der GrÃ¶ÃŸe 2
3. Falls nun 3 Bereiche der GrÃ¶ÃŸe 2: Kombiniere die Ã¤lteren
beiden Bereiche zu einem Bereich der GrÃ¶ÃŸe 4
4. usw.

âˆ’ Maximal log N Schritte: ğ‘¶ log 2 N ZeitkomplexitÃ¤t
10-23

DGIM: BEISPIEL
1001010110001011010101010101011010101010101110101010111010100010110010
Ankommen eines 1-Bits
0010101100010110101010101010110101010101011101010101110101000101100101

Vereinigung zweier Bereiche
0010101100010110101010101010110101010101011101010101110101000101100101
Ankommen weiterer Bits
0101100010110101010101010110101010101011101010101110101000101100101101
Vereinigung der Bereiche
0101100010110101010101010110101010101011101010101110101000101100101101
Vereinigung der Bereiche â€¦
0101100010110101010101010110101010101011101010101110101000101100101101

10-24

DGIM: ANFRAGEN
âˆ’ Wie viele Einsen sind unter den letzten k = 35 Bits?
A:49, B:011 A:63, B:011 A:71, B:010 A:77, B:010 A:83, B:001 A:84, B:000 A:87, B:000

âˆ’ Suche den Ã¤ltesten Bereich B dessen Zeitpunkt noch innerhalb der
neuesten k Bits liegt
âˆ’ Sei aktueller Zeitpunkt ğ‘¡ = 88
âˆ’ Ã„ltester Bereich mit ğ´ > ğ‘¡ â€“ ğ‘˜ = 53: A:63, B:011

âˆ’ SchÃ¤tze die Anzahl der Einsen durch:
âˆ’ Summe der GrÃ¶ÃŸen aller Bereiche, die komplett neuer als B sind
âˆ’ plus die HÃ¤lfte der GrÃ¶ÃŸe von B
8
2

âˆ’ Beispiel: 1 + 1 + 2 + 4 + 4 + = 16
âˆ’ TatsÃ¤chlich:1 + 1 + 2 + 4 + 4 + 6 = 18

18 Einsen

1101010101011010101010101110101010111010100010110010
10-25

DGIM: FEHLER
âˆ’ Fehler der SchÃ¤tzung: max. 50 %
âˆ’ Sei 2ğ‘Ÿ die GrÃ¶ÃŸe von B und c die tatsÃ¤chliche Anzahl an Einsen
âˆ’ c â‰¥ Anzahl der Einsen in den vorherigen Bereichen plus Eins,
c â‰¥ 1 + 2 + 4 + â‹¯ + 2ğ‘Ÿâˆ’1 + 1 = 2ğ‘Ÿ
âˆ’ Fall 1: ÃœberschÃ¤tzung - nur rechtes Bit von B ist in den N
neusten Bits
âˆ’ Es wird also maximal die HÃ¤lfte der wahren Anzahl addiert
1101010101011010101010101110101010111010100010110010

âˆ’ Fall 2: UnterschÃ¤tzung - alle Einsen von B sind in den N neusten
Bits
âˆ’ Es fehlt somit maximal die HÃ¤lfte von B
1101010101011010101010101110101010111010100010110010
10-26

DECAYING WINDOW: MOTIVATION
âˆ’ Stream: Weltweiter Verkauf von Kinokarten
âˆ’ Ziel: Auflistung der derzeit populÃ¤rsten Filme

â€¦001001

âˆ’ MÃ¶gliche LÃ¶sung:

â€¦100110

âˆ’ Ein Bitstream pro Film
âˆ’ 1 an Stelle i bedeutet, i-tes verkauftes Ticket war
fÃ¼r diesen Film
âˆ’ WÃ¤hle Window der GrÃ¶ÃŸe N zur Festlegung der AktualitÃ¤t
âˆ’ SchÃ¤tze Anzahl von Einsen z.B. via DGIM
âˆ’ Bewerte Filme anhand der geschÃ¤tzten Anzahl

â€¦010000

âˆ’ Funktioniert fÃ¼r Filme, da "geringe" Anzahl an Filmen
âˆ’ Nachteil (bei DGIM-Methode):
âˆ’ Gewichtung unabhÃ¤ngig von AktualitÃ¤t
âˆ’ Funktioniert nicht fÃ¼r Amazon-Artikel, X-User, o.Ã¤. da zu viele Elemente bzw. zu
viel Speicher nÃ¶tig
https://gds.techfak.uni-bielefeld.de/_media/teaching/2022summer/bda/lecture7-miningdatastreams2-190522.pdf
https://www.avatar.com/emojis https://emojis.sh/p/BppZaILr2A https://www.nicepng.com
10-27

EXPONENTIALLY DECAYING WINDOW
âˆ’ Alternative: Exponentially Decaying Window (EDW)
âˆ’ Anstatt Festlegung auf die letzten N Elemente, Aggregation Ã¼ber gesamten
Datenstrom und hÃ¶here Gewichtung der neuesten Elemente
âˆ’ Je Ã¤lter Elemente, desto geringer das Gewicht
âˆ’ Seien ğ’‚ğŸ , ğ’‚ğŸ , â€¦ , ğ’‚ğ‘¡ die Elemente eines Streams fÃ¼r ğ’™, mit ğ’‚1 dem ersten und ğ’‚ğ‘¡
dem aktuellsten Element und ğ‘ eine kleine Konstante (z.B. 10âˆ’6 oder 10âˆ’9)
âˆ’ MaÃŸ fÃ¼r die HÃ¤ufigkeit von ğ’™ zum aktuellsten Zeitpunkt ğ‘¡:
ğ’•

ğ‘ºğ’• (ğ’™) = à· ğ’‚ğ’Š ğŸ âˆ’ ğ’„ ğ­âˆ’ğ’Š
ğ¢=ğŸ

Gewicht

âˆ’ Einfache Aktualisierung: Bei Ankunft eines neuen Elements ğ’™ (0 oder 1)
ğ‘†ğ‘¡+1 ğ’™ = ğŸ âˆ’ ğœ ğ‘ºğ’• ğ’™ + ğ’™

10-28

EXPONENTIALLY DECAYING WINDOW

10-29

EDW THRESHOLD
âˆ’ Vorteil: Speicherung von nur einem ZÃ¤hler pro Element/Strom
âˆ’ AuÃŸerdem: LÃ¶schen von ZÃ¤hlern ğ‘ºğ’• ğ’™ , welche kleiner als ein
Schwellenwert ğ’” sind
âˆ’ Annahme: Zu jedem Zeitpunkt gibt es in einem der Streams eine 1
âˆ’ Eigenschaft der Summe aller Gewichte:

1
ğ‘

âˆ’ Bei einem Schwellenwert ğ’” kann es
1
maximal Elemente mit
ğ‘ğ‘ 
ğ‘ºğ’• ğ’™ â‰¥ ğ’” geben
1
2

âˆ’ z.B. ğ‘  = , ğ‘ = 10âˆ’6 :

1
2
= âˆ’6 = 2 âˆ— 106
cs
10

âˆ’ Die Anzahl der Elemente,
fÃ¼r die ein Wert ğ‘ºğ’• ğ’™ gespeichert
wird, ist somit begrenzt durch ğ’”

ğ’”

10-30

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl eindeutiger Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-31

FILTER AUF DATENSTRÃ–MEN
âˆ’ Leicht umsetzbare Filter
âˆ’ Attribut Alter > 18
âˆ’ Attribut Kategorie == A

âˆ’ Schwieriger: Attribut ist Element einer Menge S und S ist sehr groÃŸ
âˆ’ Problem: S passt nicht in Hauptspeicher oder mehrere Millionen
Filter, die zusammen nicht in Speicher passen
âˆ’ Beispiele:
âˆ’ E-Mail-Spam-Filter: S ist die Menge von 1 Milliarde E-Mail-Adressen
âˆ’ ~30 Zeichen Ã¡ 2 Byte (UTF-16) â‰ˆ 60GB

âˆ’ Publish-Subscribe-Systeme: z.B. Newsletter, die aus vielen
Nachrichten/BlogeintrÃ¤gen zusammengestellt und an Abonnenten mit
unterschiedlichen Interessen gesendet werden
âˆ’ Content-Filter: Jede Anzeige sollte nur einmal pro Nutzer geschaltet
werden
10-32

FILTER ÃœBER EINE EINZELNE HASH-FUNKTION
âˆ’ Array ğµ aus ğ‘› Bits und Hash-Funktion â„, welche den Wertebereich
von S gleichmÃ¤ÃŸig auf die Menge {0,1, â€¦ , ğ‘› âˆ’ 1} abbildet
âˆ’ Initialisierung:
âˆ’ Setze alle Bits auf 0
âˆ’ FÃ¼r jedes ğ‘ ïƒ ğ‘†, setze ğµ[â„(ğ‘ )] = 1

âˆ’ Anwendung: Gegeben ein Element eines Datenstroms mit Attribut a:
WÃ¤hle Element genau dann aus, wenn ğµ[â„(ğ‘)] = 1

Element a
HashFunktion h

Ausgabe des Elements, falls
ğ‘©[ğ’‰(ğ’‚)] = ğŸ

Bit-Array B 0000000000000
0010001011000
Verwirf Element, falls ğ‘©[ğ’‰(ğ’‚)] = ğŸ
10-33

FILTER ÃœBER EINE EINZELNE HASH-FUNKTION
âˆ’ Sei S eine Menge von ğ‘š Elementen und B ein Array aus ğ‘› Bits (ğ‘š < ğ‘›)
âˆ’ z.B. ğ‘š = 109 Trustful Mail-Adressen, ğ‘› = 8 âˆ— 109 ğµğ‘–ğ‘¡ (1 GB) RAM

âˆ’ ungefÃ¤hr ein Anteil
âˆ’

ğ‘š
aller Bits sind auf Eins gesetzt
ğ‘›

ğ‘š
109
1
ca. ğ‘› = 8âˆ—109 = 8 = 0.125 : 12,5% aller Bits in B sind auf 1

âˆ’ Falls ein Element a zu S gehÃ¶rt, dann ist ğµ[â„(ğ‘)] = 1 garantiert,
d.h. das Element a wird durchgelassen
â†’ Keine False Negatives
âˆ’ Falls ein Element b nicht zu S gehÃ¶rt, wird es mit einer
Wahrscheinlichkeit von ungefÃ¤hr ğŸ â€“ ğ’†âˆ’ğ’Î¤ğ’ einem Bit mit einer Eins
zugeordnet.
â†’ False Positive
âˆ’ FÃ¼r obiges Beispiel: 1 â€“ ğ‘’ âˆ’1Î¤8 = 0.1175 : Ein Element wird mit einer
Wahrscheinlichkeit von 11,75% fÃ¤lschlicherweise durchgelassen.
10-34

ALTERNATIVE: BLOOM FILTER
âˆ’ Verwende ğ‘˜ unabhÃ¤ngige Hash-Funktionen â„1 , â„2 , â€¦, â„ğ‘˜
âˆ’ Initialisierung:
âˆ’ Setze alle Bits von ğµ auf 0 (es gibt nur ein ğµ)
âˆ’ FÃ¼r jedes ğ‘ ïƒ ğ‘† setze ğµ[â„ğ‘– (ğ‘ )] = 1 fÃ¼r alle ğ‘– = 1, . . , ğ‘˜

âˆ’ FÃ¼r ein Element a aus dem Datenstrom:
âˆ’ Falls ğµ[â„ğ‘– (ğ‘)] = 1 fÃ¼r alle ğ‘– = 1, . . , ğ‘˜, gib Element aus
âˆ’ Ansonsten: Verwirf Element

âˆ’ Initialisierung: Wahrscheinlichkeit, dass ein gegebenes
Bit in B auf Eins gesetzt wurde:
1
1âˆ’ 1â€“
ğ‘›

ğ‘˜ğ‘š

â‰ˆ 1 â€“ ğ‘’ âˆ’ğ‘˜ğ‘šÎ¤ğ‘›

âˆ’ Anwendung: Wahrscheinlichkeit eines False-Positive:
1 â€“ ğ‘’ âˆ’ğ‘˜ğ‘šÎ¤ğ‘›

ğ‘˜
10-35

BLOOM FILTER: OPTIMIERUNG
âˆ’ Beispiel: 1 Milliarde E-Mail-Adressen und 1 GB Array
âˆ’ d.h. ğ‘š = 109 und ğ‘› = 8 âˆ™ 109
0.2

âˆ’ ğ‘˜ = 1: 1 â€“ ğ‘’ âˆ’1Î¤8 â‰ˆ 0.12

âˆ’ ğ‘˜ = 3: 1 â€“ ğ‘’ âˆ’3Î¤8

âˆ’ ğ‘˜ = 4:

2
3

â‰ˆ 0.05
â‰ˆ 0.03

Î¤2 4
âˆ’
1
1â€“ ğ‘’
â‰ˆ 0.024

âˆ’ â€¦
ğ‘›
âˆ’ Optimum: ğ‘˜ğ‘œğ‘ğ‘¡ = ln 2
ğ‘š

âˆ’ Beispiel: ğ‘˜ğ‘œğ‘ğ‘¡ = 8 ln 2 â‰ˆ 6
âˆ’ False Positive Rate fÃ¼r ğ‘˜ = 6:

False Positive Rate

âˆ’ ğ‘˜ = 2: 1 â€“ ğ‘’ âˆ’1Î¤4

0.18
0.16
0.14
0.12
0.1
0.08
0.06
0.04
0.02
0

2

4

6

8

10

12

14

16

18

Anzahl Hash-Funktionen k
Î¤8 6
âˆ’
6
1â€“ ğ‘’
â‰ˆ 0.0216
10-36

20

ZUSAMMENFASSUNG BLOOM FILTER
âˆ’ keine "False Negatives"
âˆ’ "False Positives" mÃ¶glich
âˆ’ Speicher-effizient
âˆ’ Ideal fÃ¼r â€schnelleâ€œ Vorverarbeitung des Streams
âˆ’ aufwendigere Nachbearbeitung dann auf deutlich weniger
Elementen

âˆ’ Berechnung der Hash-Funktion kann leicht parallelisiert
werden

10-37

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl verschiedene Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-38

ANZAHL VERSCHIEDENE ELEMENTE
âˆ’ Cardinality-Estimation problem
âˆ’ Frage: Wie viele verschiedene Elemente gibt es?
âˆ’ Frage nach Anzahl der verschiedenen Elemente, die bisher auftraten
âˆ’ Wie viele verschiedene Nutzer haben eine Webseite im letzten Monat
besucht?
âˆ’ Wie viele verschiedene Webseiten wurden von einem Nutzer
aufgerufen?
âˆ’ Wie viele verschiedene Produkte wurden letzte Woche verkauft?

âˆ’ Welches Vorgehen eignet sich, wenn die bisher gesehenen
Elemente nicht in den Hauptspeicher passen bzw. tausende
DatenstrÃ¶me gleichzeitig verarbeitet werden?
âˆ’ Ziel: SchÃ¤tzung der Anzahl mit mÃ¶glichst geringem Fehler
10-39

FLAJOLET-MARTIN ALGORITHMUS
âˆ’ Ziel: SchÃ¤tzung der Anzahl verschiedener Elemente
âˆ’ Annahme: Menge mit ğ‘š verschiedenen Elementen
âˆ’ Hash-Funktion â„ bildet ein Element e auf eine Sequenz von mind.
log 2 m Bits ab.
âˆ’ z.B. â„ ğ‘’ = 10100

âˆ’ FÃ¼r jedes Element ğ‘’, sei ğ‘Ÿ(ğ‘’) die Anzahl der hinteren Nullen von â„(ğ‘’)
âˆ’ z.B. falls â„ ğ‘’ = 10100, dann ist ğ‘Ÿ ğ‘’ = 2

âˆ’ Sei ğ‘… das Maximum von ğ‘Ÿ ğ‘’ Ã¼ber alle bisherigen Elemente
âˆ’ SchÃ¤tzer fÃ¼r die Anzahl der eindeutigen Elemente: ğŸğ‘¹
âˆ’ Intuition:
âˆ’ Je mehr verschiedene Elemente beobachtet werden (je grÃ¶ÃŸer m),
desto mehr unterschiedliche Hash-Werte werden berechnet.
âˆ’ Je mehr unterschiedliche Hash-Werte berechnet werden, desto
wahrscheinlicher ist das Auftreten eines Hash-Wertes mit vielen hinteren
Nullen.
10-40

FLAJOLET-MARTIN SCHÃ„TZER: BEGRÃœNDUNG
âˆ’ Die Werte von â„ ğ‘’ haben gleiche Wahrscheinlichkeit
âˆ’ Die Wahrscheinlichkeit einen Hash-Wert mit r hinteren Nullen zu
berechnen is 2âˆ’ğ‘Ÿ
âˆ’ UngefÃ¤hr 50% der Werte haben die Form ***0
âˆ’ UngefÃ¤hr 25% der Wert haben die Form **00
âˆ’ â€¦

âˆ’ Wahrscheinlichkeit mindestens einen Hash-Wert mit ğ‘Ÿ hinteren
Nullen durch die Eingabe von ğ‘š verschiedenen Elementen zu
beobachten ist
1 âˆ’ 2âˆ’ğ‘Ÿ ğ‘š = 1 âˆ’

ğ‘š
ğ‘Ÿ ğ‘š2âˆ’ğ‘Ÿ
âˆ’ ğ‘Ÿ
âˆ’ğ‘Ÿ
2
1âˆ’2
â‰ˆ1âˆ’ğ‘’ 2

1âˆ’
âˆ’ Beispiel: ğ‘š = 1000 (z.B. Nutzer), m soll geschÃ¤tzt werden
âˆ’ Beste SchÃ¤tzung: ğ‘… = 10

â†’

2ğ‘… = 210 = 1024

ğ‘š

ğ‘Ÿ = 9: 1 âˆ’ ğ‘’

âˆ’2ğ‘Ÿ

ğ‘š

= 0.85

ğ’“ = ğŸğŸ: 1 âˆ’ ğ‘’

âˆ’2ğ‘Ÿ

= 0.62

ğ‘š

ğ‘Ÿ = 11: 1 âˆ’ ğ‘’

âˆ’2ğ‘Ÿ

= 0.38

Problem: ÃœberschÃ¤tzung
10-41

FLAJOLET-MARTIN SCHÃ„TZER: PROBLEME
âˆ’ Simulation mit ğ‘š = 1000 und
Bit-Array der GrÃ¶ÃŸe 20
âˆ’ 10 000 Wiederholungen
âˆ’ Falls ğ‘… = 10 (24% der
FÃ¤lle), dann SchÃ¤tzung
von ğ‘š durch 2ğ‘… = 1024
âˆ’ Aber extreme ÃœberschÃ¤tzung, falls ğ‘… > 10 (38% der FÃ¤lle) durch z.B.
211 = 2048 (17%) oder 212 = 4096 (9%)
âˆ’ LÃ¶sung: Verwendung mehrerer Hash-Funktionen
âˆ’ Mittelwert: sehr anfÃ¤llig gegenÃ¼ber Extremwerten (Simulation: 5243)
âˆ’ Median: nur Zweierpotenzen (Simulation: 1024)
âˆ’ Alternative: Unterteilung in kleine Gruppen von Hash-Funktionen und
Mittelwert der Mediane
(Simulation mit Gruppen aus 50 Hash-Funktionen: 1048)
10-42

FLAJOLET'S WEITERENTWICKLUNG
âˆ’ 1984: Flajolet-Martin Algorithmus, 2003: LogLog
âˆ’ 2007: HyperLogLog (HLL)
âˆ’ Segmentierung des Bitarrays, ZÃ¤hlen der hinteren
Nullen, harmonisches Mittel bilden
âˆ’ HÃ¶here Genauigkeit, weniger Speicherbedarf
ğ‘‚(log(log(ğ‘›))
âˆ’ Industrielle Anwendung z.B. von Redis Labs zur
Komprimierung groÃŸer DatensÃ¤tze und von Google zur
ZÃ¤hlung tÃ¤glicher Suchanfragen
âˆ’ Anwendung in Elasticsearch und AWS Redshift
Paper: https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf
10-43

INHALTSVERZEICHNIS
âˆ’ EinfÃ¼hrung
âˆ’ Ziehen einer Stichprobe
âˆ’ Anfragen mit Sliding Window
âˆ’ Filter
âˆ’ Anzahl eindeutiger Elemente
âˆ’ Momente von HÃ¤ufigkeitsverteilungen

10-44

HÃ„UFIGKEITSVERTEILUNG
âˆ’ Gegeben: Datenstrom aus natÃ¼rlichen Zahlen
âˆ’ Sei ğ‘šğ‘– die Anzahl des Vorkommens von ğ‘– âˆˆ â„• im
Datenstrom
âˆ’ HÃ¤ufigkeitsverteilung

25

âˆ’ Darstellung als Histogramm:

3

20
15

1

4

2
5

10
6
5
0
10-45

MOMENTE
âˆ’ Betrachtung des Falls: Alle ğ‘šğ‘– passen nicht in den Hauptspeicher
âˆ’ Charakterisierung der HÃ¤ufigkeitsverteilung Ã¼ber deren Momente
âˆ’ Sei ğ´ âŠ‚ â„• die endliche Menge der tatsÃ¤chlich vorkommenden Zahlen
âˆ’ Das ğ¤-te Moment ğœ‡ğ‘˜ ist definiert als
1
ğœ‡ğ‘˜ =
à· ğ‘šğ‘– ğ‘˜
|ğ´|
ğ‘–âˆˆğ´

âˆ’ 1te Moment = Arithmetisches Mittel ğ‘š
à´¥=

1
Ïƒ ğ‘š
|ğ´| ğ‘–âˆˆğ´ ğ‘–

âˆ’ 2te Moment = MaÃŸ der Ungleichheit (Varianz)
âˆ’ z.B. Datenstrom aus 100 Elementen mit ğ´ = 1, 2, . . , 11
âˆ’ ğ‘šğ‘– : 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 â†’ 2tes Moment: 82.7
âˆ’ ğ‘šğ‘– : 90, 1, 1, 1, 1, 1, 1, 1 ,1, 1, 1 â†’ 2tes Moment: 737.3

âˆ’ Anmerkung: Empirische Varianz: (2te Moment) â€“ (1te Moment)2
10-46

ALON-MATIAS-SZEGEDY (AMS) ALGORITHMUS
âˆ’ SchÃ¤tzung des 2-ten Moments
âˆ’ Speicherung einer groÃŸen (durch den Hauptspeicher begrenzten)
Anzahl an Variablen ğ‘‹1 , ğ‘‹2 , â€¦, ğ‘‹ğ‘™ mit ğ‘‹ğ‘— = ğ‘‹ğ‘— . ğ‘’ğ‘™ğ‘’ğ‘š, ğ‘‹ğ‘— . ğ‘£ğ‘ğ‘™
âˆ’ Sei ğ‘› die LÃ¤nge des Datenstroms (eigentlich unbekannt)
âˆ’ FÃ¼r jede Variable ğ‘‹ğ‘—
âˆ’ WÃ¤hle (gleichmÃ¤ÃŸig) zufÃ¤llig einen Zeitpunkt ğ‘¡ (ğ‘¡ â‰¤ ğ‘›)
âˆ’ ğ‘‹ğ‘— . ğ‘’ğ‘™ğ‘’ğ‘š = ğ‘–, wobei ğ‘– âˆˆ ğ´ das Element des Datenstroms zum Zeitpunkt ğ‘¡
âˆ’ ğ‘‹ğ‘— . ğ‘£ğ‘ğ‘™ = ğ‘ğ‘¡ , wobei ğ‘ğ‘¡ die Anzahl des Vorkommens von ğ‘– ab Zeitpunkt ğ’•
ğ’„ğ’• : ğŸ ğŸ ğŸ ğŸ‘

â€¦

(ğ’ğ’ƒ âˆ’ğŸ) (ğ’ğ’‚ âˆ’ğŸ) ğ’ğ’ƒ (ğ’ğ’‚ âˆ’ğŸ)

ğ’ğ’‚

âˆ’ Sei ğ‘“ ğ‘‹ğ‘— = ğ‘›(2 âˆ™ ğ‘‹ğ‘— . ğ‘£ğ‘ğ‘™ â€“ 1)

âˆ’ SchÃ¤tzer des 2-ten Moments:
1 1 ğ‘™
ğ‘†=
âˆ— à· ğ‘“ ğ‘‹ğ‘—
|ğ´| ğ‘™
ğ‘—=1
10-47

ALON-MATIAS-SZEGEDY ALGORITHMUS
âˆ’ Momente hÃ¶herer Ordnung
âˆ’ FÃ¼r das k-te Moment:

ğ‘“ ğ‘‹ = ğ‘› (ğ‘ ğ‘˜ âˆ’ ğ‘ âˆ’ 1 ğ‘˜ ), wobei X. ğ‘£ğ‘ğ‘™ = ğ‘
âˆ’ Beispiel: k = 3

ğ‘“ ğ‘‹ = ğ‘› (3ğ‘ 2 âˆ’ 3c + 1)
âˆ’ In Praxis: Anstatt Mittelwert Ã¼ber alle Variablen, Median Ã¼ber
Mittelwerte von kleineren Gruppen von Variablen
âˆ’ Unbegrenzte Daten (ğ‘› unbekannt): LÃ¶sung Ã¼ber Reservoir Sampling
âˆ’ StichprobengrÃ¶ÃŸe ğ‘™
âˆ’ WÃ¤hle ersten ğ‘™ Zeitpunkte fÃ¼r die Variablen
ğ‘™

âˆ’ Wenn das ğ‘›-te Element (ğ‘› > ğ‘™) auftritt, wÃ¤hle es mit Wahrscheinlichkeit ğ‘›

âˆ’ Falls das ğ‘›-te Element als neue Variable gewÃ¤hlt wird, entferne eine
1
existierende Variable mit Wahrscheinlichkeit ğ‘™
10-48

ZUSAMMENFASSUNG
âˆ’ Data Stream Model
âˆ’ Ein- und Ausgabe als Stream, Standing Queries, begrenzter
Zwischenspeicher (State)

âˆ’ Stichprobe (Sampling)
âˆ’ Feste GrÃ¶ÃŸe (Reservoir Sampling) oder fester Anteil

âˆ’ AbschÃ¤tzen der Einsen in einem Window
âˆ’ z.B. via DGIM und EDW

âˆ’ Speichereffizientes Filtern via Bloom-Filter
âˆ’ Geringer Speicherbedarf und keine False-Negatives, aber FalsePositives mÃ¶glich

âˆ’ ZÃ¤hlen eindeutiger Elemente: z.B. via Flajolet-Martin Alg.
âˆ’ Charakterisierung der HÃ¤ufigkeitsverteilung durch Momente
âˆ’ SchÃ¤tzung des 2. Moments z.B. via Alon-Matias-Szegedy
Algorithmus

10-49

